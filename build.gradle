buildscript {
    repositories {
        mavenCentral()
        maven { url = "https://repo1.maven.org/maven2/" }
        maven { url = "https://maven.google.com/" }
        maven {
            name = "sonatype"
            url = "https://oss.sonatype.org/content/repositories/snapshots/"
        }
    }
    dependencies {
        classpath 'com.guardsquare:proguard-gradle:7.2.2'
    }
}

plugins {
    id 'java-library'
    id 'fabric-loom' version '1.0-SNAPSHOT'
    id 'maven-publish'
    id 'net.ltgt.errorprone' version '3.0.1'
    id 'com.github.spotbugs' version '5.0.13'
}

repositories {
    maven { url = "https://maven.terraformersmc.com/releases/" }
    maven { url "https://maven.shedaniel.me/" }
}

// Reproducible builds! https://docs.gradle.org/4.9/userguide/working_with_files.html#sec:reproducible_archives
tasks.withType(AbstractArchiveTask) {
    preserveFileTimestamps = false
    reproducibleFileOrder = true
}

apply plugin: 'java'

// TODO add compilation with Java toolchains

sourceCompatibility = JavaVersion.VERSION_17
targetCompatibility = JavaVersion.VERSION_17

final def compiler = javaToolchains.compilerFor {
    languageVersion = JavaLanguageVersion.of(17)
}

import groovy.json.JsonOutput
import groovy.json.JsonSlurper
import proguard.gradle.ProGuardTask
import net.fabricmc.loom.task.RemapJarTask

archivesBaseName = project.archives_base_name
version = project.mod_version
group = project.maven_group

//final def modName = project.mod_name
final def build_release = System.getenv("BUILD_RELEASE") == "true"

// Add snapshot suffix to version if not building a release.
// To build a release, set the environment variable BUILD_RELEASE to true.
if (!build_release) {
    version += "-SNAPSHOT"
}

configurations {
    // Another list of dependencies to use with ProGaurd, as ForgeGradle isn't happy about resolving it the normal way.
    // I'm not happy about it either.
    proguardHack
}

dependencies {
    // To change the versions see the gradle.properties file
    minecraft "com.mojang:minecraft:${project.minecraft_version}"
    mappings "net.fabricmc:yarn:${project.yarn_mappings}:v2"
    modImplementation "net.fabricmc:fabric-loader:${project.loader_version}"

    // Fabric API. This is technically optional, but you probably want it anyway.
    modImplementation "net.fabricmc.fabric-api:fabric-api:${project.fabric_version}"
    //proguardHack "net.fabricmc.fabric-api:fabric-api:${project.fabric_version}"

    // Mod menu
    modCompileOnlyApi "com.terraformersmc:modmenu:4.0.6"
    //proguardHack "com.terraformersmc:modmenu:4.0.6"

    // Cloth config
    modCompileOnlyApi "me.shedaniel.cloth:cloth-config-fabric:8.2.88"
    //proguardHack "me.shedaniel.cloth:cloth-config-fabric:8.2.88"

    // NullAway
    annotationProcessor "com.uber.nullaway:nullaway:0.10.3"

    // JetBrains null annotations
    compileOnly "org.jetbrains:annotations:23.0.0"
    proguardHack "org.jetbrains:annotations:23.0.0"

    // SpotBugs annotations
    compileOnly "com.github.spotbugs:spotbugs-annotations:4.7.3"
    proguardHack "com.github.spotbugs:spotbugs-annotations:4.7.3"

    // Error Prone
    errorprone "com.google.errorprone:error_prone_core:2.16"
    compileOnly "com.google.errorprone:error_prone_annotations:2.16"
    proguardHack "com.google.errorprone:error_prone_annotations:2.16"
}

//jar.finalizedBy('reobfJar')

processResources {
    // This will ensure that this task is redone when the versions change.
    inputs.property "version", project.mod_version

    // Replace values in only fabric.mod.json.
    filesMatching("fabric.mod.json") {
        expand "version": project.mod_version
    }

    // Minify .json files in built .jar
    doLast {
        fileTree(dir: outputs.files.asPath, includes: [
            "**/*.json"
        ]).each { final File file ->
            file.text = JsonOutput.toJson(new JsonSlurper().parse(file))
        }
    }
}

import net.ltgt.gradle.errorprone.CheckSeverity

tasks.withType(JavaCompile) {
    options.release = 17

    // Ensures that the encoding of source files is set to UTF-8, see http://yodaconditions.net/blog/fix-for-java-file-encoding-problems-with-gradle.html
    options.encoding = "UTF-8"
    // Tells Gradle to include more debug information in compiled .class files. For the optimised files, this will be removed by ProGuard.
    options.debug = true
    options.debugOptions.debugLevel = "source,lines,vars"

    // NullAway configuration
    options.errorprone {
        check("NullAway", CheckSeverity.ERROR)
        option("NullAway:AnnotatedPackages", "iDiamondhunter.morebows")
    }
}

// This task creates a .jar file containing a deobfuscated version of this mod, for ProGuard to minimise.
task unmappedJar(type: Jar) {
    classifier = "unmapped"
    from sourceSets.main.output
}

// This task uses ProGuard to shrink the built .jar's file size and optimise the bytecode. TODO Cleanup.
task proguard(dependsOn: unmappedJar, type: ProGuardTask) {
    verbose

    // TODO Fix
    outputs.upToDateWhen { false }

    // Use the non-remapped .jar as the input file, because ForgeGradle has a convenient task to map it to obfuscated Minecraft class names for us when we're done optimising it
    injars "build/libs/" + rootProject.name + "-" + version + "-unmapped.jar"
    outjars "build/libs/" + rootProject.name + "-" + version + "-proguard-unmapped.jar"

    // Get the Java standard library from the provided toolchain.
    libraryjars compiler.get().metadata.installationPath.asFile.absolutePath + "/jmods/java.base.jmod", jarfilter: '!**.jar', filter: '!module-info.class'

    // Add relevant Minecraft libraries to ProGuard's list of libraries to obfuscate against.
    // TODO this is very janky
    libraryjars project.configurations.compileClasspath

    // Add the dependencies to ProGuard's list of libraries to obfuscate against. I'd love a more sane way of doing this.
    //libraryjars project.configurations.proguardHack

    // The rest of the configs are in this file
    configuration 'guard.pro'
}

/*
// TODO This breaks loom, no idea how to make it work
task remapProguardJar(type: RemapJarTask) {
    //outputs.upToDateWhen { false }
    dependsOn(proguard)
    //mustRunAfter(proguard)
    input.fileValue(proguard.outputs.files.singleFile)
    archiveClassifier.set("proguard-mapped")
}

prepareRemapProguardJar.dependsOn(proguard)
*/

artifacts.add('archives', file(proguard.outputs.files.singleFile)) {
    type('jar')
    builtBy(proguard)
}

// TODO depends on loom implementation details I don't understand
remapJar {
    dependsOn(proguard)
    input.fileValue(proguard.outputs.files.singleFile)
    //archiveClassifier.set("debug")
}

prepareRemapJar.dependsOn(proguard)

java {
    // Loom will automatically attach sourcesJar to a RemapSourcesJar task and to the "build" task
    // if it is present.
    // If you remove this line, sources will not be generated.
    withSourcesJar()
}

// TODO this is a bit dumb
task deleteProGuardOutput(type: Delete, dependsOn: proguard) {
    delete proguard.outputs.files.singleFile
}

build.finalizedBy(cleanUnmappedJar, deleteProGuardOutput)

publishing {
    publications {
        mavenJava(MavenPublication) {
            artifact(remapJar) {
                builtBy remapJar
            }
            artifact(sourcesJar) {
                builtBy remapSourcesJar
            }
        }
    }
}
